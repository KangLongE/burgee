문제 입력 형식
위 두 줄은 문제 지문
1. 문제
2. 보기
3. 5지
4. 선다
5. 형 맞춰서 하세요
3 // 답 숫자로만 쓰시오 바로 밑에 적어야해 한 칸 띄면 안돤다..
다음 중 C 언어에서 정수를 입력받는 함수로 가장 적절한 것은 무엇인가? //하급 문제

printf()
scanf()
gets()
puts()
fopen()
2
다음 중 C 언어에서 정수형 변수를 올바르게 선언한 것은 무엇인가?

int 1num;
integer num;
int num;
num int;
int = num;
3
다음 중 C 언어에서 조건문에 해당하는 키워드는 무엇인가?

switch
if
loop
function
case
2
다음 중 C 언어에서 문자 하나를 저장하기에 적절한 자료형은 무엇인가?

int
float
char
double
long
3
다음 중 C 언어에서 배열을 선언하는 방법으로 올바른 것은 무엇인가?

int array;
int array(10);
int array[];
int array[10];
int[10] array;
4
다음 중 C 언어에서 무한 루프를 만드는 코드로 올바른 것은 무엇인가?

for (i = 0; i < 10; i--)
while (1)
if (1)
do while (1)
repeat until (0)
2
다음 중 C 언어에서 포인터 변수 선언이 올바른 것은 무엇인가?

int ptr;
int* ptr();
*int ptr;
int *ptr;
ptr int*;
4
다음 중 C 언어에서 포인터 변수 선언이 올바른 것은 무엇인가?

int ptr;
int* ptr();
*int ptr;
int *ptr;
ptr int*;
4
다음 중 printf() 함수에서 정수 출력 형식 지정자로 올바른 것은 무엇인가?

%c
%s
%d
%f
%lf
3
다음 중 C 언어의 논리 연산자가 아닌 것은 무엇인가?

&&
||
!
==
!=
4
다음 중 C 언어에서 파일을 쓰기 모드로 여는 함수 호출은 무엇인가?

fopen("file.txt", "r")
fopen("file.txt", "w")
fopen("file.txt", "rw")
fwrite("file.txt")
fread("file.txt")
2
다음 중 C 언어에서 문자 상수를 표현하는 방법은?

"a"
'a'
a
"abc"
'abc'
2
다음 중 C 언어에서 부울(Boolean) 값을 나타내는 자료형은?

bool
boolean
int
char
void
3
다음 중 C 언어에서 주석을 작성하는 올바른 방법은?

// 주석 내용
/* 주석 내용 */
# 주석 내용
<!-- 주석 내용 -->
A, B 모두 맞음
5
다음 중 변수의 초기화가 올바른 것은?

int num = 10;
int num; = 10
int num 10;
int = 10 num;
num int = 10;
1
다음 중 배열을 함수의 인자로 전달할 때 발생하는 현상으로 올바른 설명은? //중급

배열 전체가 복사된다.
배열은 포인터로 전달된다.
배열은 전역변수가 된다.
배열 크기를 반드시 전달해야 한다.
배열 인자는 사용할 수 없다.
2
다음 중 malloc() 함수에 대한 설명으로 옳지 않은 것은?

동적 메모리를 할당한다.
반환값은 void 포인터이다.
할당된 메모리는 자동으로 해제된다.
stdlib.h 헤더 파일이 필요하다.
반환값을 형 변환하여 사용하는 것이 일반적이다.
3
다음 중 문자열을 비교하는 함수로 가장 적절한 것은?

strcpy()
strcat()
strcmp()
strlen()
scanf()
3
다음 중 함수 포인터에 대한 선언으로 올바른 것은?

int ptr(int*);
int *ptr(int);
int (*ptr)(int);
(*int ptr)(int);
int ptr(*)(int);
3
다음 중 포인터를 사용하여 배열의 각 요소에 접근하는 코드로 올바른 것은?

arr = arr + 1;
*(arr + i) = 10;
arr(i) = 10;
*arr[i] = 10;
arr -> i = 10;
2
다음 중 C 언어에서 포인터와 배열의 관계에 대한 설명으로 올바른 것은?

배열은 포인터가 아니다.
포인터는 배열의 크기를 자동으로 추적한다.
배열 이름은 배열의 첫 번째 요소의 주소이다.
포인터는 배열보다 항상 느리다.
배열은 포인터와 완전히 동일한 개념이다.
3
다음 중 free() 함수에 대한 설명으로 틀린 것은?

malloc 또는 calloc으로 할당된 메모리를 해제한다.
포인터가 가리키는 메모리를 해제한다.
해제 후 해당 포인터는 자동으로 NULL이 된다.
stdlib.h에 선언되어 있다.
메모리 누수를 방지하기 위해 사용된다.
3
다음 중 함수 포인터를 선언하고 사용하는 올바른 예는?//상급

int ptr(*f)(int);
int (*f)(int) = &func;
int *f(int) = &func;
func = (*int)(f);
int f = (*func)(int);
2
다음 중 2차원 배열을 함수에 전달하는 방법으로 올바른 것은?

void func(int arr[][])
void func(int *arr[])
void func(int arr[][10])
void func(int **arr)
void func(arr[10][10])
3
다음 중 포인터 산술 연산으로 잘못된 것은?

ptr + 1
ptr - 1
ptr++
ptr = ptr + 4.5
*(ptr + 2)
4
다음 중 포인터 배열 선언으로 올바른 것은?

int *arr();
int arr(*)[];
int *arr[5];
int (*arr)[5];
int arr[5]*;
3
다음 중 동적 2차원 배열 할당으로 올바른 코드는?

int **arr = malloc(sizeof(int*));
int arr = malloc(5 * 5);
int **arr = malloc(5 * sizeof(int*));
int *arr[5] = malloc(sizeof(int));
int *arr = malloc(5)[5];
3
다음 중 구조체 포인터에서 멤버 접근이 올바른 것은?

(*ptr).x
*ptr.x
ptr(x)
ptr->*x
ptr.x
1
다음 중 재귀 함수의 기본 구성에 반드시 포함되어야 하는 것은?

반복문
파일 입출력
종료 조건
switch 문
포인터 연산
3
다음 중 const int *p;의 의미는 무엇인가?

p는 상수를 가리킨다.
p는 값을 변경할 수 있다.
*p는 수정 가능하다.
p와 *p 모두 상수이다.
*p는 다른 주소를 가리킨다.
1
다음 중 함수 포인터 배열 선언으로 올바른 것은?

int *fptr[](int);
int (*fptr[3])(int);
int *(*fptr[3])(int);
int fptr[3]*();
int *fptr[3]();
2
다음 중 문자열 길이를 구하는 함수는?

strcpy()
strcat()
strlen()
strcmp()
malloc()
3
다음 중 문자열 길이를 구하는 함수는?

strcpy()
strcat()
strlen()
strcmp()
malloc()
3
다음 코드의 결과는?
int a = 5; printf("%d", a++ + ++a);
10
11
미정 (정의되지 않음)
12
컴파일 에러
3
다음 중 동적 메모리 누수를 방지하는 방법으로 옳은 것은?

free()를 호출하지 않는다.
메모리 주소를 초기화하지 않는다.
malloc() 후 free()를 반드시 호출한다.
sizeof를 생략한다.
realloc()으로만 해제한다.
3
다음 중 다차원 배열을 포인터로 받는 함수 선언은?

void func(int **arr);
void func(int arr[][]);
void func(int arr[10][10]);
void func(*arr[10][10]);
void func(arr[][]);
3
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
다음 중 포인터를 사용하는 이유로 올바르지 않은 것은?

함수 인자 전달
동적 메모리 할당
메모리 직접 접근
메모리 누수 방지
배열 처리
4
다음 중 다음 코드의 출력 결과는? int a=10; int *p=&a; printf("%d", *p);

10
주소값
0
에러
주소값의 크기
1
다음 중 포인터를 NULL로 설정하는 이유는?

초기화 미흡 방지
메모리 할당
함수 호출
포인터 연산
디버깅
1
다음 중 다음 코드의 문제점은? int *p; printf("%d", *p);

정상 실행
초기화되지 않은 포인터 사용
컴파일 오류
NULL 포인터 참조
할당된 메모리 없음
2
다음 중 배열 포인터를 선언하는 방법은?

int (*ptr)[10];
int *ptr[10];
int ptr*;
int ptr[10];
int *ptr;
1
다음 중 동적 메모리 할당 함수가 아닌 것은?

malloc()
calloc()
free()
realloc()
new()
3
다음 중 포인터 연산에서 올바른 것은?

포인터 + 정수
포인터 + 포인터
정수 + 정수
포인터 * 정수
정수 * 포인터
1
다음 중 포인터를 통한 배열 접근 방법으로 옳은 것은?

*(arr + i)
arr[i]
arr + i
*(i + arr)
모두 해당
5
다음 중 함수 포인터를 선언하는 방법은?

int (*func)(int);
int func*();
int *func();
func int*();
int func();
1
다음 중 구조체 포인터가 멤버에 접근하는 올바른 방법은?

ptr->member
(*ptr).member
ptr.member
*ptr.member
ptr*member
1
다음 중 다음 코드의 출력 결과는? char str[]="hello"; char *p=str; printf("%c", *(p+1));

e
h
l
o
a
1
다음 중 포인터를 사용해 함수에서 값을 변경할 수 있는 이유는?

주소 전달
값 복사
복사본 전달
주소 복사
함수 호출
1
다음 중 다음 코드의 출력 결과는? int arr[3]={1,2,3}; int *p=arr; printf("%d", *(p+2));

3
1
2
0
에러
1
다음 중 포인터 변수가 가리키는 메모리를 해제하는 함수는?

malloc()
calloc()
free()
realloc()
alloc()
3
다음 중 이중 포인터 선언 방법으로 올바른 것은?

int **ptr;
int *ptr*;
int ptr**;
*int ptr*;
int ptr*;
1
다음 중 포인터 변수가 가리키는 주소를 출력하는 함수는?

printf("%d", ptr);
printf("%p", ptr);
printf("%c", ptr);
printf("%f", ptr);
printf("%s", ptr);
2
다음 중 포인터를 증가시키는 연산자는?

ptr++;
ptr--;
ptr+=2;
ptr=ptr+1;
위의 모두
5
다음 중 다음 코드의 문제점은? int *p=NULL; *p=10;

정상 실행
NULL 포인터 참조
초기화 누락
할당 누락
컴파일 오류
2
다음 중 포인터 배열 선언은?

int *arr[10];
int (*arr)[10];
int arr*;
int *arr;
int arr[10];
1
다음 중 다음 코드 출력 결과는? int a=5; int *p=&a; *p=10; printf("%d", a);

10
5
0
에러
주소값
1
다음 중 포인터 변수의 크기가 결정되는 기준은?

컴파일러
변수 타입
운영체제
포인터 타입
메모리 주소 크기
5
다음 중 const 포인터 선언으로 올바른 것은?

int * const p;
const int *p;
int const *p;
int *p const;
const * int p;
1
다음 중 다음 코드 출력 결과는? int a=3; int *p=&a; printf("%d", *p + 2);

5
3
2
에러
주소값
1
다음 중 포인터 산술 연산에서 올바르지 않은 것은?

포인터 + 정수
포인터 - 정수
포인터 - 포인터
포인터 * 정수
정수 + 포인터
4
다음 중 배열명과 포인터의 관계로 올바른 것은?

배열명은 포인터 상수이다
배열명은 변수이다
배열명은 함수이다
배열명은 주소를 변경할 수 있다
배열명은 NULL이다
1
다음 중 void 포인터의 특징으로 맞는 것은?

어떤 타입의 포인터로도 변환 가능
오직 int형 데이터만 가리킼 수 있다
메모리를 할당하지 않는다
포인터 산술 연산이 가능하다
주소를 직접 출력할 수 없다
1
다음 중 다음 코드에서 포인터를 이용한 올바른 변수 접근법은? struct Point { int x; int y; }; struct Point p={1,2}; struct Point *ptr=&p;

ptr->x
*ptr.x
ptr.x
*ptr->x
ptr->*x
1
다음 중 다음 코드 출력 결과는? int arr[]={1,2,3,4,5}; int *p=arr+3; printf("%d", *p);

4
3
5
2
1
1
다음 중 다음 코드에서 동적 메모리 할당 함수는?

malloc()
free()
realloc()
calloc()
alloc()
1
다음 중 다음 코드에서 포인터 초기화가 올바른 것은? int *p;

p = NULL;
p = 0;
p = &p;
p = *p;
p = NULLPTR;
1
다음 중 다음 코드에서 올바른 포인터 복사 방법은? int *p1; int *p2;

p1 = p2;
p1 = &p2;
p1 = *p2;
p1 = NULL;
p1 = 0;
1
다음 중 다음 코드에서 포인터 증가 연산 후 값 출력은? int arr[]={10,20,30}; int *p=arr; p++; printf("%d", *p);

20
10
30
에러
0
1
다음 중 포인터가 NULL일 때 가능한 작업은?

메모리 접근
할당 해제
역참조
초기화
오류 발생
4
다음 중 포인터의 기본값으로 적절한 것은?

0
-1
NULL
포인터 변수의 주소
무작위 값
3
다음 중 다음 코드의 출력 결과는? char *str="abc"; printf("%c", *(str+2));

c
a
b
\0
에러
1
다음 중 다음 코드에서 포인터를 이용해 변수 값을 바꾸는 함수 선언은?

void func(int p);
void func(int p);
void func(*int p);
int func(int *p);
int func(*p);
1
다음 중 다음 중 구조체 포인터에서 멤버에 접근하는 올바른 방법은?

ptr->member
ptr.member
(*ptr).member
ptr.member
ptrmember
1
다음 중 다음 코드에서 포인터를 올바르게 비교하는 방법은?

if (p1 == p2)
if (p1 = p2)
if (p1 != p2)
if (*p1 == *p2)
if (&p1 == &p2)
1
다음 중 다음 코드에서 포인터가 가리키는 메모리 주소를 출력하는 올바른 printf 서식 지정자는?

%d
%p
%c
%f
%s
2
다음 중 다음 코드에서 포인터를 통한 배열 요소 접근법으로 올바른 것은?

*(arr + i)
arr[i]
&arr[i]
arr + i
i[arr]
1
다음 중 다음 코드에서 포인터 변수 선언이 올바른 것은?

int ptr;
int ptr;
int &ptr;
int ptr;
*int ptr;
1
다음 중 다음 중 void 포인터를 사용할 때 주의해야 할 점은?

포인터 산술 연산을 할 수 없다
어떤 타입이든 가리킬 수 없다
역참조할 때 타입을 변환해야 한다
메모리 할당이 자동으로 된다
함수 인자로 사용할 수 없다
3
다음 중 다음 중 포인터 산술 연산의 결과가 정의되지 않는 경우는?

두 포인터가 같은 배열 내에 있을 때
포인터를 배열 밖으로 이동시킬 때
포인터에 정수를 더할 때
포인터 간의 빼기 연산
정수에 포인터를 더할 때
2
다음 중 다음 코드에서 포인터 변수 p의 초기값으로 가장 적절한 것은?

NULL
1
0
-1
쓰레기 값
1
다음 중 다음 중 동적 메모리 할당 시 사용하지 않는 함수는?

malloc()
calloc()
alloc()
realloc()
free()
3
다음 중 다음 코드에서 포인터를 통한 구조체 멤버 접근법으로 올바른 것은?

ptr->member
(*ptr).member
ptr.member
ptr.member
ptrmember
1
다음 중 다음 코드에서 포인터 연산 후 결과가 올바른 것은?

p++ 포인터가 다음 메모리 주소를 가리킨다
p-- 포인터가 이전 메모리 주소를 가리킨다
p + 2 포인터가 두 칸 앞으로 이동한다
p - 1 포인터가 한 칸 뒤로 이동한다
모두 맞다
5
다음 중 다음 중 포인터 변수 선언 시 올바른 형태는?

int* p;
int *p;
int * p;
int *p ;
모두 올바르다
5
다음 중 다음 중 포인터 변수를 역참조할 때 사용하는 연산자는?

&
*
->
++
2
다음 중 다음 중 다음 코드에서 포인터와 배열 이름의 관계로 맞는 것은?

배열 이름은 배열 첫 번째 요소의 주소이다
배열 이름은 포인터 변수이다
배열 이름은 변경 가능한 포인터이다
배열 이름은 메모리 할당 함수이다
배열 이름은 함수이다
1
다음 중 다음 중 다음 코드에서 포인터 변수 p에 NULL을 할당하는 올바른 방법은?

p = NULL;
p = 0;
p = nullptr;
p = NULLPTR;
p = (int*)0;
1
다음 중 다음 중 포인터가 가리키는 메모리 주소를 출력할 때 사용하는 printf 서식 지정자는?

%d
%c
%p
%f
%s
3
다음 중 다음 중 다음 코드에서 포인터를 이용해 값을 변경하는 함수 선언은?

void func(int p);
int func(int p);
void func(int p);
int func(int p);
void func(*int p);
1
다음 중 다음 중 다음 코드에서 동적 메모리 할당 후 메모리를 해제하는 함수는?

malloc()
free()
calloc()
realloc()
alloc()
2
다음 중 다음 중 다음 코드에서 포인터 증가 연산 후 가리키는 값이 출력되는 경우는?

int *p=arr; p++;
printf("%d", *p);
배열의 두 번째 요소 값
배열의 첫 번째 요소 값
배열의 세 번째 요소 값
1
다음 중 다음 중 다음 코드에서 포인터를 비교하는 올바른 방법은?

if (p1 == p2)
if (p1 = p2)
if (*p1 == *p2)
if (&p1 == &p2)
if (p1 != p2)
1
다음 중 다음 중 포인터를 사용하여 문자열을 출력할 때 사용하는 함수는?

printf()
scanf()
gets()
puts()
fopen()
4
다음 중 다음 중 다음 코드에서 포인터 변수 p가 가리키는 값에 1을 더하는 방법은?

(*p)++
*p++
p++
++*p
p + 1
1
다음 중 다음 중 다음 코드에서 포인터 변수 p가 배열의 첫 번째 요소를 가리키도록 하는 올바른 방법은?

p = arr;
p = &arr;
p = arr[0];
p = &arr[0];
p = *arr;
1
다음 중 다음 중 다음 코드에서 다음의 출력 결과는? char *str = "Hello"; printf("%c", *(str+1));

e
H
l
o
\0
1
다음 중 다음 코드에서 포인터 배열을 선언하는 올바른 방법은?

int arr[10];
int (arr)[10];
int arr [10];
int arr[10];
int arr10;
1
다음 중 다음 코드에서 포인터를 함수 인자로 넘길 때 올바른 방법은?

void func(int *p);
func(&var);
func(p);
func(*p);
func(&p);
2
다음 중 다음 중 포인터를 NULL로 초기화하는 올바른 이유는?

안전한 초기화
메모리 누수 방지
컴파일러 오류 방지
코드 최적화
함수 호출 필요
1
다음 중 다음 중 포인터와 배열 이름의 차이점으로 올바른 것은?

배열 이름은 상수 포인터
포인터는 상수 배열
배열 이름은 변경 가능
포인터는 배열 아님
배열 이름과 포인터는 같음
1
다음 중 다음 중 포인터가 가리키는 값을 변경하는 연산자는?

&
++
+=
1
다음 중 다음 중 다음 코드에서 포인터 산술 연산의 결과가 잘못된 경우는?

포인터가 배열 끝을 넘어설 때
포인터에 정수를 더할 때
포인터끼리 뺄 때
포인터를 함수 인자로 넘길 때
포인터를 역참조할 때
1
다음 중 다음 중 다음 코드에서 포인터와 배열의 관계를 설명한 것은?

배열은 포인터의 상수
포인터는 배열의 상수
배열과 포인터는 같음
배열 이름은 포인터 변수
포인터는 배열 이름과 동일
1
다음 중 다음 중 포인터가 가리키는 메모리 주소를 출력할 때 사용하는 포맷 지정자는?

%d
%c
%p
%f
%s
3
다음 중 다음 중 포인터 변수를 선언하는 올바른 방법은?

int* p;
int p;
int * p;
int p;
모두 맞다
5
다음 중 다음 중 동적 메모리 할당 함수가 아닌 것은?

malloc()
calloc()
realloc()
free()
alloc()
5
다음 중 다음 중 포인터를 함수 인자로 넘길 때 올바른 방법은?

func(p);
func(&p);
func(p);
func(p);
func(&*p);
1
다음 중 다음 중 포인터 변수에 NULL을 할당하는 올바른 방법은?

p = NULL;
p = 0;
p = nullptr;
p = (int*)0;
모두 맞다
5
다음 중 다음 중 포인터 산술 연산에서 올바른 것은?

p++
p--
p + 2
p - 1
모두 맞다
5
다음 중 다음 중 포인터 변수 p가 배열의 첫 번째 요소를 가리키는 올바른 방법은?

p = arr;
p = &arr[0];
p = *arr;
p = &arr;
p = arr[1];
2
다음 중 다음 중 다음 코드에서 포인터 변수를 통해 값을 변경하는 올바른 방법은?

*p = 10;
p = 10;
*p++;
++p;
p++;
1
다음 중 다음 중 포인터가 가리키는 값을 출력할 때 사용하는 서식 지정자는?

%d
%p
%c
%s
%f
2
다음 중 다음 중 다음 코드에서 포인터가 가리키는 값에 1을 더하는 올바른 방법은?

(*p)++
*p++
p++
++*p
p + 1
1
다음 중 다음 중 다음 코드에서 포인터 변수 선언이 올바른 것은?

int p;
int p;
int &p;
*int p;
int p;
1
다음 중 다음 코드에서 이중 포인터 선언이 올바른 것은?

int **pp;
int pp;
int p;
int p;
int **ppp;
1
다음 중 다음 중 이중 포인터를 사용하여 값을 변경하는 올바른 방법은?

**pp = 10;
*pp = 10;
pp = 10;
pp++;
**pp++;
1
다음 중 다음 중 포인터 배열과 배열 포인터의 차이로 올바른 것은?

포인터 배열은 포인터들의 배열
배열 포인터는 배열을 가리키는 포인터
둘은 같다
포인터 배열은 배열 포인터의 별칭
배열 포인터는 포인터 배열의 별칭
2
다음 중 다음 중 다음 코드에서 void 포인터를 정수 포인터로 변환하는 올바른 방법은?

int p = (int)vp;
int *p = vp;
int *p = &vp;
int *p = *vp;
int p = (void)vp;
1
다음 중 다음 중 포인터 연산에서 올바르지 않은 것은?

포인터끼리 빼기 가능
포인터에 정수 더하기 가능
포인터에 포인터 더하기 불가
포인터 빼기 결과는 정수
포인터 증가 시 자료형 크기 만큼 이동
3
다음 중 다음 중 포인터가 가리키는 값을 안전하게 해제하는 함수는?

free()
delete()
delete
dispose()
release()
1
다음 중 다음 중 포인터가 가리키는 메모리를 할당하는 함수는?

malloc()
free()
realloc()
calloc()
new()
1
다음 중 다음 중 포인터와 관련된 동적 메모리 할당 함수가 아닌 것은?

malloc()
calloc()
realloc()
free()
alloc()
5
다음 중 다음 중 다음 코드에서 포인터 변수 p가 가리키는 값에 접근하는 올바른 방법은?

p
p
&p
p->
*&p
1
다음 중 다음 중 다음 코드에서 문자열 상수를 가리키는 포인터 선언으로 올바른 것은?

char *str = "hello";
char str = "hello";
char str = hello;
char str = "hello";
char *str = 'hello';
1
다음 중 다음 중 포인터를 통해 배열 요소에 접근하는 올바른 방법은?

*(arr + i)
arr[i]
arr + i
*arr[i]
&arr[i]
1
다음 중 다음 중 포인터가 가리키는 변수의 값을 증가시키는 연산자는?

++*p
*p++
++p
p++
*p + 1
1
다음 중 다음 중 포인터 변수가 가리키는 주소를 출력하는 포맷 지정자는?

%p
%d
%s
%c
%f
1
다음 중 다음 중 다음 코드에서 배열 이름이 포인터로 사용되는 경우 올바른 것은?

arr == &arr[0]
arr == arr[0]
&arr == arr
arr == *arr
arr == &arr
1
다음 중 다음 중 다음 코드에서 다음 포인터 선언이 올바른 것은?

int p;
int p;
int * p;
모두 맞다
없음
4
다음 중 다음 중 동적 메모리 할당 함수가 반환하는 값이 올바른 것은?

할당된 메모리 주소
NULL
포인터 값
함수 포인터
정수 값
1
다음 중 다음 중 다음 중 이중 포인터를 선언하는 올바른 문법은?

int **pp;
int pp;
int p;
int p;
int **ppp;
1
다음 중 다음 중 포인터 변수를 함수 인자로 전달하는 올바른 방법은?

func(&p);
func(p);
func(p);
func(p);
func(&*p);
2
다음 중 다음 중 배열 이름이 포인터처럼 사용되는 경우 올바른 것은?

arr == &arr[0]
arr == arr[0]
&arr == arr
arr == *arr
arr == &arr
1
다음 중 다음 중 포인터 변수 p가 가리키는 값을 변경하는 올바른 방법은?

*p = 10;
p = 10;
*p++;
*p = &x;
p++;
1
다음 중 다음 중 다음 코드에서 포인터를 사용해 문자열을 출력하는 함수는?

printf("%s", str);
printf("%d", *str);
puts(str);
scanf("%s", str);
gets(str);
3
다음 중 다음 중 다음 중 void 포인터에 대해 올바른 설명은?

모든 포인터 타입으로 변환 가능하다
값을 직접 변경할 수 있다
포인터 산술 연산이 가능하다
void 포인터는 초기화할 수 없다
void 포인터는 상수 포인터이다
1
다음 중 다음 중 포인터 변수 선언에서 올바르지 않은 것은?

int p;
char ptr;
float ptr*;
double dp;
int p2;
3
다음 중 다음 중 포인터 연산에서 올바르지 않은 것은?

포인터끼리 더하기는 불가능하다
포인터끼리 빼기는 가능하다
포인터에 정수 더하기 가능하다
포인터 빼기 결과는 정수이다
포인터 증가 시 자료형 크기 만큼 이동한다
1
다음 중 다음 중 동적 메모리 할당 함수가 아닌 것은?

malloc()
calloc()
free()
realloc()
alloc()
5
다음 중 다음 중 포인터를 통해 배열 요소에 접근하는 올바른 방법은?

*(arr + i)
arr[i]
arr + i
*arr[i]
&arr[i]
1
다음 중 다음 중 포인터 변수를 NULL로 초기화하는 올바른 방법은?

int *p = NULL;
int *p = 0;
int *p;
int *p = '\0';
int *p = nullptr;
1
다음 중 다음 중 포인터 변수를 선언하는 올바른 방법은?

int p;
int p;
int * p;
모두 맞다
없음
4
다음 중 다음 중 포인터 변수를 통해 변수의 값을 증가시키는 올바른 표현은?

(*p)++;
*p++;
++p;
p++;
*p + 1;
1
다음 중 다음 중 포인터를 사용하는 함수 인자 전달 시 주로 사용하는 방법은?

포인터를 값으로 전달한다
포인터의 주소를 전달한다
포인터 자체를 전달한다
포인터의 값 복사본을 전달한다
포인터를 반환한다
3
다음 중 다음 중 다음 코드에서 포인터 연산 후 값을 출력하는 올바른 문장은?

printf("%d", *p);
printf("%d", p);
printf("%d", &p);
printf("%d", *p++);
printf("%d", ++*p);
1
다음 중 다음 중 포인터 변수가 가리키는 메모리를 해제하는 함수는?

free()
delete()
dispose()
release()
realloc()
1
다음 중 다음 중 다음 중 포인터가 가리키는 주소를 출력하는 포맷 지정자는?

%p
%d
%s
%c
%f
1
다음 중 다음 중 다음 코드에서 이중 포인터를 사용하는 올바른 문법은?

int **pp;
int pp;
int p;
int p;
int **ppp;
1
다음 중 다음 중 다음 중 포인터를 선언하는 올바른 문법은?

int p;
int p;
int * p;
모두 맞다
없음
4
다음 중 다음 중 다음 중 포인터 연산에서 올바르지 않은 것은?

포인터끼리 더하기는 불가능하다
포인터끼리 빼기는 가능하다
포인터에 정수 더하기 가능하다
포인터 빼기 결과는 정수이다
포인터 증가 시 자료형 크기 만큼 이동한다
1
다음 중 다음 중 포인터를 사용해 문자열을 복사하는 함수는?

strcpy()
strncpy()
strcat()
strlen()
strcmp()
1
다음 중 다음 중 포인터를 통해 동적 메모리 할당을 하는 올바른 함수는?

malloc()
free()
calloc()
realloc()
alloc()
1
다음 중 포인터 변수 선언이 올바른 것은?

int p;
float ptr;
char ptr;
double p;
int p;
1
다음 중 배열의 이름이 가리키는 것은?

배열의 첫 번째 요소 주소
배열 전체 크기
배열 변수의 값
배열의 마지막 요소 주소
배열 변수의 자료형
1
다음 중 포인터 연산에서 올바른 것은?

포인터에 정수 더하면 주소가 이동한다
포인터와 포인터 더하기 가능하다
포인터끼리 곱셈이 가능하다
포인터를 문자열로 바꿀 수 있다
포인터끼리 나누기 가능하다
1
다음 중 동적 메모리 할당 함수가 아닌 것은?

malloc()
calloc()
free()
realloc()
alloc()
5
다음 중 포인터가 가리키는 값을 변경하는 올바른 방법은?

*p = 100;
p = 100;
*p++;
p++;
*p = &x;
1
다음 중 포인터를 NULL로 초기화하는 올바른 방법은?

int *p = NULL;
int *p = 0;
int *p;
int *p = '\0';
int *p = nullptr;
1
다음 중 다음 중 void 포인터에 대한 설명으로 올바른 것은?

모든 타입 포인터로 변환 가능
포인터 산술 연산 가능
포인터 값 직접 변경 가능
초기화 불가
상수 포인터
1
다음 중 다음 중 배열 요소에 포인터로 접근하는 올바른 방법은?

*(arr + i)
arr[i]
arr + i
*arr[i]
&arr[i]
1
다음 중 다음 중 포인터 변수를 통해 변수 값을 증가시키는 올바른 표현은?

(*p)++;
*p++;
++p;
p++;
*p + 1;
1
다음 중 포인터 변수를 선언하는 올바른 문법은?

int p;
int p;
int * p;
모두 맞다
없음
4
다음 중 포인터를 사용하는 함수 인자 전달 방식으로 맞는 것은?

포인터 자체 전달
값 복사 전달
주소 복사 전달
포인터 포인터 전달
참조 전달
1
다음 중 포인터 변수 p가 가리키는 주소를 출력하는 포맷 지정자는?

%p
%d
%s
%c
%f
1
다음 중 다음 중 문자열을 포인터로 출력하는 함수는?

printf("%s", str);
printf("%d", *str);
puts(str);
scanf("%s", str);
gets(str);
3
다음 중 다음 중 포인터 변수 p가 가리키는 메모리를 해제하는 함수는?

free()
delete()
dispose()
release()
realloc()
1
다음 중 다음 중 포인터 변수 선언이 올바르지 않은 것은?

int val;
int* ptr();
float ptr*;
char ptr;
ptr double;
3
다음 중 다음 중 포인터 연산 후 값을 출력하는 올바른 문장은?

printf("%d", *p);
printf("%d", p);
printf("%d", &p);
printf("%d", *p++);
printf("%d", ++*p);
1
다음 중 포인터끼리 덧셈이 불가능한 이유는?

메모리 주소이기 때문에
자료형이 다르기 때문에
컴파일 오류 때문
산술 연산 제한 때문에
컴퓨터 구조 때문
1
다음 중 다음 중 이중 포인터 선언으로 올바른 것은?

int **pp;
int pp;
int p;
int p;
int **ppp;
1
다음 중 다음 중 동적 메모리 할당 함수 중 크기 지정과 초기화까지 하는 함수는?

calloc()
malloc()
realloc()
free()
alloc()
1
다음 중 포인터 변수를 초기화하지 않고 사용했을 때 발생할 수 있는 문제는?

예상치 못한 값 참조
컴파일 오류
런타임 경고
메모리 해제 오류
초기화 자동 실행
1
다음 중 포인터를 사용해 배열의 모든 요소에 접근하는 올바른 방법은?

for(int i=0; i<n; i++) printf("%d", *(arr + i));
for(int i=0; i<n; i++) printf("%d", arr[i]);
for(int i=0; i<n; i++) printf("%d", arr+i);
for(int i=0; i<n; i++) printf("%d", *arr[i]);
for(int i=0; i<n; i++) printf("%d", &arr[i]);
1
다음 중 포인터 연산에서 올바른 것은?

p + 1는 다음 변수 주소를 가리킨다
p - 1는 다음 변수 주소를 가리킨다
p * 2는 주소를 두 배로 만든다
p / 2는 주소를 반으로 만든다
p + p는 두 포인터를 더한 값이다
1
다음 중 다음 중 포인터 변수의 크기를 알아내는 함수는?

sizeof(p)
length(p)
size(p)
count(p)
sizeof(*p)
1
다음 중 포인터가 가리키는 값을 출력하는 올바른 방법은?

printf("%d", *p);
printf("%d", p);
printf("%p", p);
printf("%c", p);
printf("%s", p);
1
다음 중 다음 중 포인터로 구조체 멤버에 접근하는 올바른 방법은?

ptr->member
(ptr).member
ptr.member
ptrmember
*ptr.member
1
다음 중 포인터 변수 선언에서 올바른 것은?

int ptr;
int ptr;
int * ptr;
모두 맞다
없음
4
다음 중 다음 중 포인터 변수가 가리키는 주소를 바꾸는 올바른 표현은?

p = &x;
*p = &x;
p = x;
*p = x;
p == &x;
1
다음 중 다음 중 함수에 포인터를 인자로 전달할 때 사용하는 이유는?

함수 내에서 변수 값을 직접 변경하기 위해
함수 호출 속도를 빠르게 하기 위해
코드를 간결하게 하기 위해
함수에 변수 이름을 넘기기 위해
함수에 복사본을 넘기기 위해
1
다음 중 포인터와 배열의 관계로 옳은 것은?

배열 이름은 배열의 첫 번째 요소 주소를 가진다
포인터는 배열 크기를 가진다
배열 이름은 포인터가 아니다
포인터는 배열의 값을 직접 저장한다
배열은 포인터의 별칭이 아니다
1
다음 중 포인터를 사용하는 이유로 적절하지 않은 것은?

효율적인 메모리 사용
동적 메모리 할당 가능
배열과 문자열 처리 편리
변수 직접 값 변경
변수명 생략 가능
5
다음 중 다음 중 포인터 산술 연산에서 주의할 점은?

포인터끼리 덧셈은 불가능하다
포인터와 정수 덧셈은 가능하다
포인터끼리 뺄셈은 가능하다
포인터에 정수 곱셈은 불가능하다
포인터끼리 곱셈 가능하다
1
다음 중 다음 중 이중 포인터 사용 예가 아닌 것은?

포인터 배열 선언
포인터의 포인터 선언
포인터를 인자로 전달할 때
2차원 배열 동적 할당
단일 변수 주소 저장
5
다음 중 포인터 변수를 NULL로 초기화하는 올바른 표현은?

int *p = NULL;
int *p = 0;
int *p = '\0';
int *p = nullptr;
int *p;
1
다음 중 포인터 변수의 값을 바꾸려면?

*p = 값;
p = 값;
*p++;
p++;
*p = &값;
1
다음 중 다음 중 동적 메모리 해제 함수는?

free();
delete();
dispose();
release();
realloc();
1
다음 중 포인터와 함수 호출 시 올바른 설명은?

포인터를 통해 함수 안 변수 값 변경 가능
포인터는 함수에 복사본 전달
포인터는 상수 전달
포인터는 값을 복사해서 전달
포인터는 항상 참조 전달
1
다음 중 다음 중 포인터와 문자열 처리에 사용되는 함수는?

strcpy();
strlen();
strcmp();
strcat();
모두 맞다
5
다음 중 포인터 산술 연산에서 잘못된 것은?

포인터 + 정수 가능
포인터 - 정수 가능
포인터 + 포인터 불가능
포인터 * 정수 불가능
포인터 / 정수 가능
5
다음 중 다음 중 포인터를 이용한 변수 값 증가 표현은?

(*p)++;
*p++;
++p;
p++;
*p + 1;
1
다음 중 다음 중 포인터로 배열 요소 접근 시 올바른 것은?

*(arr + i);
arr[i];
&arr[i];
arr + i;
*arr[i];
1
다음 중 포인터 변수 p가 가리키는 값을 출력하는 올바른 문장은?

printf("%d", *p);
printf("%d", p);
printf("%p", p);
printf("%s", p);
printf("%c", *p);
1
다음 중 다음 중 이중 포인터 선언으로 올바른 것은?

int pp;
int pp;
int pp;
int pp;
int **ppp;
1
다음 중 다음 중 포인터가 NULL인 경우 할 수 없는 작업은?

*p = 10;
p = NULL;
p == NULL 확인;
포인터 초기화;
NULL 포인터 비교;
1
다음 중 다음 중 함수 인자 전달 시 포인터 사용의 장점은?

함수 내에서 원본 값 변경 가능
함수 호출 속도 증가
복사본 전달로 안정성 확보
메모리 낭비 증가
디버깅 용이
1
다음 중 다음 중 동적 메모리 할당 함수 malloc()의 반환 타입은?

void*
int*
char*
float*
double*
1
다음 중 포인터 연산에서 p+1이 의미하는 것은?

다음 변수의 주소
현재 주소에서 1 증가
메모리 크기만큼 이동
다음 주소+1 바이트
이중 포인터 이동
1
다음 중 다음 중 포인터로 구조체 멤버에 접근하는 방법은?

ptr->member
(ptr).member
ptr.member
ptrmember
*ptr.member
1
다음 중 포인터 산술 연산에서 잘못된 것은?

포인터 + 정수 가능
포인터 - 정수 가능
포인터 + 포인터 불가능
포인터 * 정수 불가능
포인터 / 정수 가능
5
다음 중 다음 중 포인터 변수를 초기화하지 않고 사용하면 발생할 수 있는 문제는?

예상치 못한 값 참조
컴파일 오류
런타임 경고
메모리 해제 오류
초기화 자동 실행
1
다음 중 다음 중 포인터 변수 선언이 올바르지 않은 것은?

int val;
int* ptr();
float ptr*;
char ptr;
ptr double;
3
다음 중 다음 중 포인터 변수 p가 가리키는 주소를 출력하는 올바른 포맷 지정자는?

%p
%d
%s
%c
%f
1
다음 중 다음 중 포인터 변수를 NULL로 초기화하는 올바른 방법은?

int *p = NULL;
int *p = 0;
int *p;
int *p = '\0';
int *p = nullptr;
1
다음 중 포인터 변수 p가 가리키는 메모리를 해제하는 함수는?

free()
delete()
dispose()
release()
realloc()
1
다음 중 포인터 변수를 선언하는 올바른 문법은?

int p;
int p;
int * p;
모두 맞다
없음
4
다음 중 다음 중 포인터와 배열의 관계로 옳은 것은?

배열 이름은 배열의 첫 번째 요소 주소를 가진다
포인터는 배열 크기를 가진다
배열 이름은 포인터가 아니다
포인터는 배열의 값을 직접 저장한다
배열은 포인터의 별칭이 아니다
1
다음 중 포인터와 함수 호출 시 올바른 설명은?

포인터를 통해 함수 안 변수 값 변경 가능
포인터는 함수에 복사본 전달
포인터는 상수 전달
포인터는 값을 복사해서 전달
포인터는 항상 참조 전달
1
다음 중 다음 중 포인터 산술 연산에서 주의할 점은?

포인터끼리 덧셈은 불가능하다
포인터와 정수 덧셈은 가능하다
포인터끼리 뺄셈은 가능하다
포인터에 정수 곱셈은 불가능하다
포인터끼리 곱셈 가능하다
1
다음 중 포인터 변수 p가 가리키는 값을 증가시키는 올바른 표현은?

(*p)++;
*p++;
++p;
p++;
*p + 1;
1
다음 중 포인터 변수 선언에서 올바른 것은?

int ptr;
int ptr;
int * ptr;
모두 맞다
없음
4
다음 중 다음 중 동적 메모리 할당 함수 중 크기 지정과 초기화까지 하는 함수는?

calloc()
malloc()
realloc()
free()
alloc()
1
다음 중 포인터 변수 p가 가리키는 값을 출력하는 올바른 문장은?

printf("%d", *p);
printf("%d", p);
printf("%p", p);
printf("%s", p);
printf("%c", *p);
1
다음 중 다음 중 이중 포인터 선언으로 올바른 것은?

int pp;
int pp;
int pp;
int pp;
int **ppp;
1
다음 중 다음 중 포인터가 NULL인 경우 할 수 없는 작업은?

*p = 10;
p = NULL;
p == NULL 확인;
포인터 초기화;
NULL 포인터 비교;
1
다음 중 다음 중 함수 인자 전달 시 포인터 사용의 장점은?

함수 내에서 원본 값 변경 가능
함수 호출 속도 증가
복사본 전달로 안정성 확보
메모리 낭비 증가
디버깅 용이
1
다음 중 다음 중 동적 메모리 할당 함수 malloc()의 반환 타입은?

void*
int*
char*
float*
double*
1
다음 중 포인터 연산에서 p+1이 의미하는 것은?

다음 변수의 주소
현재 주소에서 1 증가
메모리 크기만큼 이동
다음 주소+1 바이트
이중 포인터 이동
1
다음 중 다음 중 포인터로 구조체 멤버에 접근하는 방법은?

ptr->member
(ptr).member
ptr.member
ptrmember
*ptr.member
1
다음 중 포인터 산술 연산에서 잘못된 것은?

포인터 + 정수 가능
포인터 - 정수 가능
포인터 + 포인터 불가능
포인터 * 정수 불가능
포인터 / 정수 가능
5
다음 중 다음 중 포인터 변수를 초기화하지 않고 사용하면 발생할 수 있는 문제는?

예상치 못한 값 참조
컴파일 오류
런타임 경고
메모리 해제 오류
초기화 자동 실행
1
다음 중 다음 중 포인터 변수 선언이 올바르지 않은 것은?

int val;
int* ptr();
float ptr*;
char ptr;
ptr double;
3
다음 중 다음 중 포인터 변수 p가 가리키는 주소를 출력하는 올바른 포맷 지정자는?

%p
%d
%s
%c
%f
1
다음 중 다음 중 포인터 변수를 NULL로 초기화하는 올바른 방법은?

int *p = NULL;
int *p = 0;
int *p;
int *p = '\0';
int *p = nullptr;
1
다음 중 포인터 변수 p가 가리키는 메모리를 해제하는 함수는?

free()
delete()
dispose()
release()
realloc()
1
다음 중 포인터 변수를 선언하는 올바른 문법은?

int p;
int p;
int * p;
모두 맞다
없음
4
다음 중 다음 중 포인터와 배열의 관계로 옳은 것은?

배열 이름은 배열의 첫 번째 요소 주소를 가진다
포인터는 배열 크기를 가진다
배열 이름은 포인터가 아니다
포인터는 배열의 값을 직접 저장한다
배열은 포인터의 별칭이 아니다
1
다음 중 포인터와 함수 호출 시 올바른 설명은?

포인터를 통해 함수 안 변수 값 변경 가능
포인터는 함수에 복사본 전달
포인터는 상수 전달
포인터는 값을 복사해서 전달
포인터는 항상 참조 전달
1
다음 중 다음 중 포인터 산술 연산에서 주의할 점은?

포인터끼리 덧셈은 불가능하다
포인터와 정수 덧셈은 가능하다
포인터끼리 뺄셈은 가능하다
포인터에 정수 곱셈은 불가능하다
포인터끼리 곱셈 가능하다
1
다음 중 포인터 변수 p가 가리키는 값을 증가시키는 올바른 표현은?

(*p)++;
*p++;
++p;
p++;
*p + 1;
1
다음 중 포인터 변수 선언에서 올바른 것은?

int ptr;
int ptr;
int * ptr;
모두 맞다
없음
4
다음 중 다음 중 동적 메모리 할당 함수 중 크기 지정과 초기화까지 하는 함수는?

calloc()
malloc()
realloc()
free()
alloc()
1
다음 중 포인터를 사용하여 두 변수의 값을 서로 교환하는 방법으로 올바른 것은?

void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; }
void swap(int a, int b) { int temp = a; a = b; b = temp; }
void swap(int *a, int b) { int temp = *a; *a = b; b = temp; }
void swap(int a, int *b) { int temp = a; a = *b; *b = temp; }
void swap(int a, int b) { a = b; b = a; }
1
다음 중 포인터가 가리키는 메모리를 다른 메모리 주소로 변경하는 올바른 방법은?

p = &x;
*p = &x;
p == &x;
*p == x;
&p = x;
1
다음 중 배열과 포인터에 대한 설명으로 올바른 것은?

배열 이름은 배열 첫 번째 요소의 주소를 나타낸다
포인터는 배열의 크기를 포함한다
배열과 포인터는 완전히 동일한 타입이다
포인터는 배열을 대체할 수 없다
배열의 크기는 포인터로 알 수 있다
1
다음 중 포인터가 NULL인지 확인하는 올바른 방법은?

if (p == NULL)
if (p = NULL)
if (p != NULL)
if (p)
if (p = 0)
1
다음 중 동적 메모리 할당 시 할당 실패를 확인하는 방법으로 올바른 것은?

if (ptr == NULL)
if (ptr != NULL)
if (ptr = NULL)
if (ptr)
if (!ptr)
1
다음 중 포인터를 통해 문자열을 출력하는 올바른 함수는?

printf("%s", str);
printf("%d", str);
printf("%c", str);
printf("%f", str);
printf("%p", str);
1
다음 중 이중 포인터 선언에서 올바른 것은?

int ptr;
int ptr;
int ptr;
int** ptr;
모두 맞다
5
다음 중 포인터 변수가 가리키는 주소를 변경할 수 없는 경우는?

const int *p;
int *const p;
int **p;
int *p;
const int **p;
2
다음 중 함수 매개변수로 포인터를 전달하는 주요 이유는?

함수 내에서 원본 데이터를 변경하기 위해
함수 호출 시 복사 비용을 줄이기 위해
메모리 사용을 줄이기 위해
함수 내부에서 포인터를 선언하기 위해
위 모두
5
다음 중 다음 중 포인터 연산으로 올바른 것은?

p + 1은 다음 메모리 블록 주소를 가리킨다
p * 2는 주소를 두 배로 증가시킨다
p / 2는 주소를 반으로 줄인다
p - p는 0이 아니다
p + p는 두 배 주소이다
1
다음 중 포인터와 배열을 이용해 배열 요소에 접근하는 올바른 방법은?

*(arr + i)
arr[i]
i[arr]
모두 맞다
없음
4
다음 중 동적 메모리 해제를 하지 않으면 발생할 수 있는 문제는?

메모리 누수
컴파일 오류
런타임 오류
포인터 오류
논리 오류
1
다음 중 포인터를 NULL로 초기화 하는 가장 안전한 방법은?

int *p = NULL;
int *p = 0;
int *p;
int p = (int)0;
int *p = nullptr;
1
다음 중 다음 중 이중 포인터가 사용되는 경우는?

포인터를 가리키는 포인터를 다룰 때
2차원 배열을 사용할 때
함수에서 포인터의 포인터를 수정할 때
모두 맞다
없음
4
다음 중 포인터 산술 연산에서 증가된 값이 의미하는 것은?

다음 변수의 메모리 주소
포인터 변수 자체 증가
메모리 크기 단위로 주소 이동
정수 값 증가
주소의 바이트 단위 증가
3
다음 중 포인터를 선언하는 올바른 문법은?

int p;
int p;
int * p;
모두 맞다
없음
4
다음 중 포인터 변수를 이용해 문자열을 출력하는 함수는?

printf("%s", p);
printf("%c", *p);
printf("%d", p);
printf("%f", p);
printf("%p", p);
1
다음 중 다음 중 동적 메모리 할당 함수 realloc()의 주요 기능은?

이미 할당된 메모리 크기를 조절한다
새 메모리를 할당한다
메모리를 해제한다
메모리 크기를 반환한다
메모리 크기를 확인한다
1
다음 중 포인터를 사용해 문자열 길이를 구하는 함수로 올바른 것은?

int strlen_custom(char *str) { int len=0; while(*str++) len++; return len; }
int strlen_custom(char *str) { int len=0; while(str[len]!='\0') len++; return len; }
int strlen_custom(char *str) { int len=0; while(*str!='\0') { len++; str++; } return len; }
int strlen_custom(char *str) { return sizeof(str); }
int strlen_custom(char *str) { return 0; }
3
다음 중 포인터 배열과 배열 포인터에 대한 설명으로 옳은 것은?

포인터 배열은 포인터들의 배열이다
배열 포인터는 배열 전체를 가리킨다
둘은 동일하다
포인터 배열은 포인터 하나만 포함한다
배열 포인터는 포인터 하나만 포함한다
1
다음 중 포인터가 가리키는 데이터를 안전하게 변경하는 방법은?

const_cast<int*>(p);
*p = 10;
(const int)p = 10;
포인터를 변경할 수 없다
*p++;
2
다음 중 다음 코드에서 포인터 연산의 결과가 올바른 것은?

int arr[5] = {1,2,3,4,5}; int *p = arr; p = p + 3;
*p의 값은 4이다
*p의 값은 3이다
*p의 값은 5이다
p의 값은 arr+2이다
p의 값은 arr+4이다
1
다음 중 포인터가 가리키는 메모리를 해제할 때 사용하는 함수는?

free()
malloc()
calloc()
realloc()
new()
1
다음 중 포인터를 선언할 때 올바른 예는?

int* ptr;
int *ptr;
int * ptr;
모두 맞다
없음
4
다음 중 포인터가 가리키는 값을 출력하는 printf 서식 지정자는?

%d
%f
%s
%p
%c
1
다음 중 포인터가 NULL인 경우 가장 안전하게 처리하는 방법은?

if (ptr != NULL) { /* 사용 / }
if (ptr = NULL) { / 사용 / }
if (ptr == 0) { / 사용 */ }
ptr = NULL;
포인터 무조건 사용
1
다음 중 함수에 포인터를 인자로 넘길 때의 장점은?

함수 내부에서 값 수정 가능
복사 비용 감소
대용량 데이터 전달 시 효율적
모두 맞다
없음
4
다음 중 포인터 변수를 증가시키면?

다음 요소의 주소로 이동한다
포인터 값이 1 증가한다
포인터 값이 4 증가한다
포인터가 0이 된다
포인터가 NULL이 된다
1
다음 중 포인터 변수 p가 가리키는 값을 10으로 변경하는 코드로 올바른 것은?

*p = 10;
p = 10;
&p = 10;
*p == 10;
p == 10;
1
다음 중 다음 중 메모리 누수를 방지하는 올바른 방법은?

동적 할당한 메모리를 해제한다
메모리를 할당하지 않는다
포인터를 NULL로 초기화한다
포인터를 복사한다
포인터를 증가시킨다
1
다음 중 포인터 변수 선언 시 틀린 것은?

int* p;
int p;
int * p;
int p;
int* p;
4
다음 중 이중 포인터를 사용하는 이유로 옳은 것은?

포인터를 가리키는 포인터를 사용하기 위해
2차원 배열을 사용할 때
함수에서 포인터를 변경하기 위해
모두 맞다
없음
4
다음 중 동적 메모리 할당 함수 malloc()의 반환값은?

할당된 메모리의 주소
할당된 메모리의 크기
메모리 크기
포인터 변수
NULL 또는 메모리 주소
5
다음 중 포인터와 배열 이름의 가장 큰 차이점은?

배열 이름은 상수 주소이고, 포인터는 변경 가능하다
포인터는 상수 주소이고, 배열 이름은 변경 가능하다
둘 다 변경 가능하다
둘 다 상수 주소이다
없음
1
다음 중 포인터 연산에서 포인터 간의 차이(p2 - p1)의 의미는?

두 요소 사이의 개수
두 포인터의 주소 차이(바이트)
포인터 값의 합
포인터 값의 차이(정수)
없음
1
다음 중 다음 중 문자열을 포인터로 선언하는 올바른 방법은?

char *str = "Hello";
char str[] = "Hello";
char str = "Hello";
char *str = 'Hello';
char *str = Hello;
1
다음 중 포인터가 가리키는 배열 요소에 접근하는 올바른 방법은?

*(arr + i)
arr[i]
i[arr]
모두 맞다
없음
4
다음 중 포인터의 크기를 확인하는 방법으로 적절한 것은?

sizeof(ptr)
sizeof(ptr)
sizeof(&ptr)
sizeof(ptr)
sizeof(int)
1
다음 중 함수 포인터를 선언하는 올바른 방법은?

int (*func_ptr)(int);
int *func_ptr(int);
int func_ptr(int);
int func_ptr(int);
int func_ptr();
1
다음 중 포인터 변수를 초기화하지 않은 상태에서 사용하는 결과는?

정의되지 않은 동작
컴파일 오류
런타임 오류
0 출력
자동 0 초기화
1
다음 중 포인터 연산에서 p++를 실행하면 포인터가 이동하는 단위는?

포인터가 가리키는 자료형 크기
항상 1바이트
항상 4바이트
항상 8바이트
임의 크기
1
다음 중 다음 코드의 출력 결과는?

int a=10; int *p=&a; printf("%d", *p);
10
주소 출력
컴파일 오류
0 출력
알 수 없음
1
다음 중 포인터를 사용하는 이유로 적절하지 않은 것은?

효율적인 메모리 관리
함수 간 데이터 전달
복사 비용 절감
모든 변수 자동 초기화
동적 메모리 할당 가능
4
다음 중 포인터 연산에서 *(p+1)이 의미하는 것은?

포인터 p가 가리키는 다음 요소의 값
포인터 p의 값에 1 더한 값
포인터 p의 주소 값
포인터 p의 다음 주소 값
포인터 p가 가리키는 값
1
다음 중 다음 중 잘못된 포인터 연산은?

포인터와 정수 더하기
두 포인터 빼기
포인터와 포인터 곱하기
포인터 증가
포인터 감소
3
다음 중 포인터 변수가 가리키는 값을 바꾸려면 어떻게 해야 하나?

*p = 새값;
p = 새값;
&p = 새값;
*p == 새값;
p == 새값;
1
다음 중 다음 중 포인터 변수 p가 가리키는 메모리를 해제하는 올바른 함수는?

free(p);
delete p;
malloc(p);
calloc(p);
realloc(p);
1
다음 중 다음 중 포인터 변수가 배열의 시작 주소를 저장하는 방법으로 옳은 것은?

int arr[5]; int *p = arr;
int *p = &arr[0];
int *p = arr + 0;
모두 맞다
없음
4
다음 중 포인터 변수를 0으로 초기화하는 방법은?

int *p = NULL;
int *p = 0;
int p = (int)0;
모두 맞다
없음
4
다음 중 다음 중 다중 포인터를 올바르게 선언한 예는?

int **pp;
int pp;
int ** pp;
모두 맞다
없음
4
다음 중 포인터와 배열의 관계에 대한 설명으로 틀린 것은?

배열 이름은 배열 첫 요소의 주소이다
포인터는 배열 요소를 가리킬 수 있다
배열 이름을 포인터로 변경할 수 있다
포인터는 배열 크기를 저장한다
포인터는 배열처럼 사용 가능하다
4
다음 중 포인터 변수의 값을 출력할 때 적절한 printf 서식 지정자는?

%p
%d
%s
%f
%c
1
다음 중 다음 중 포인터 연산에서 p--가 수행하는 동작은?

포인터가 이전 요소를 가리킨다
포인터가 1 감소한다
포인터가 0이 된다
포인터가 증가한다
포인터가 NULL이 된다
1
다음 중 동적 메모리를 할당하는 함수는?

malloc()
free()
printf()
scanf()
fopen()
1
다음 중 double 포인터를 올바르게 선언한 것은?

int ptr;
int ptr;
int ptr;
double ptr;
int *(*ptr);
1
다음 중 포인터 배열에 대한 설명으로 옳지 않은 것은?

포인터 배열은 포인터들을 원소로 가진 배열이다
각 원소는 주소를 저장한다
문자열 배열에도 사용된다
모든 원소는 반드시 같은 주소를 가리켜야 한다
배열 인덱스를 통해 접근 가능하다
4
다음 중 포인터와 NULL에 대한 설명으로 옳은 것은?

NULL은 주소 0을 의미한다
NULL은 포인터에만 사용할 수 있다
NULL은 항상 1이다
NULL은 예약된 키워드다
NULL은 반드시 초기화 필요하다
1
다음 중 다음 코드의 출력 결과는?

char *str = "Hello"; printf("%c", *str);
H
e
l
o
\0
1
다음 중 포인터와 함수에 대한 설명으로 옳은 것은?

포인터로 함수의 인자를 수정할 수 있다
함수는 포인터를 반환할 수 없다
포인터는 함수 외부에서만 사용 가능
함수는 포인터를 인자로 받을 수 없다
포인터는 지역 변수에만 사용
1
다음 중 다음 중 잘못된 포인터 선언은?

int *p;
float *f;
char c;
double d;
void *v;
4
다음 중 포인터를 사용해야 하는 경우가 아닌 것은?

동적 메모리 사용
배열 전달
큰 구조체 복사
상수 사용
데이터 공유
4
다음 중 다음 코드에서 잘못된 부분은?

int a = 5; int *p = &a; *p = 10;
없음
*p는 주소여야 한다
&가 잘못되었다
포인터 초기화 오류
a는 const여야 한다
1
다음 중 문자열을 포인터로 선언한 예는?

char *str = "abc";
char str = "abc";
char str[] = {'a','b','c'};
char str[] = {"abc"};
char str = "abc";
1
다음 중 다음 코드의 의미는?

int *p = NULL;
p는 아무것도 가리키지 않는다
p는 0을 가리킨다
p는 int 값을 가진다
p는 포인터가 아니다
오류 발생
1
다음 중 동적 메모리 해제 후 포인터의 적절한 처리 방법은?

NULL로 설정
그대로 둠
0으로 설정
다시 할당
오류 발생
1
다음 중 다음 중 double 포인터를 사용할 수 있는 경우는?

2차원 배열
함수 포인터
정수형 변수
float형 배열
void 포인터
1
다음 중 포인터에 주소를 대입하는 방법으로 옳은 것은?

p = &a;
p = a;
*p = a;
&p = a;
*p = &a;
1
다음 중 포인터 변수가 할당되지 않은 주소에 접근하면?

정의되지 않은 동작
0이 출력됨
오류 없음
주소값이 증가
자동 초기화
1
다음 중 다음 중 void 포인터의 특징은?

형 변환 없이 역참조 불가능
모든 자료형 가리킬 수 없음
항상 정수형만 가리킴
sizeof는 0이다
사용할 수 없다
1
다음 중 포인터를 사용하는 장점은?

동적 메모리 할당 가능
메모리 낭비 증가
속도 저하
복사 비용 증가
버그 증가
1
다음 중 다음 코드의 의미는?

int a = 10; int *p = &a;
p는 a의 주소를 저장한다
p는 a의 값이다
p는 포인터가 아니다
a는 주소를 저장한다
*p는 주소이다
1
다음 중 포인터 연산에서 유효한 것은?

p + 1
p - 1
p++
p--
모두 맞다
5
다음 중 포인터를 통해 배열 요소에 접근할 수 없는 방법은?

arr[i]
*(arr + i)
i[arr]
arr -> i
*(&arr[i])
4
다음 중 문자열을 복사할 때 사용하는 함수는?

strcpy()
strcat()
strlen()
strcmp()
sprintf()
1
다음 중 포인터가 메모리에서 해제된 주소를 가리킬 때 발생할 수 있는 문제는?

댕글링 포인터
메모리 누수
정상 동작
컴파일 에러
할당 오류
1
다음 중 포인터의 기본 크기(32bit 시스템)는?

4바이트
8바이트
2바이트
1바이트
시스템에 따라 다름
1
다음 중 포인터를 함수 인자로 전달했을 때 함수 내부에서 값을 변경할 수 있는 이유는?

주소를 직접 참조하기 때문
복사본이 전달되기 때문
지역변수가 사용되기 때문
스택 메모리를 참조하기 때문
힙 메모리를 공유하기 때문
1
다음 중 다음 코드에서 발생할 수 있는 문제는?

int *p; *p = 10;
정의되지 않은 동작
컴파일 에러
런타임 에러
p는 값이다
없음
1
다음 중 포인터가 다른 포인터를 가리키는 경우는?

이중 포인터
배열 포인터
함수 포인터
포인터 배열
상수 포인터
1
다음 중 포인터와 배열의 차이에 대한 설명으로 올바른 것은?

포인터는 다른 주소로 변경 가능하지만 배열 이름은 불가능
배열은 동적 메모리 할당을 지원하지만 포인터는 아님
포인터는 항상 정적 크기를 가짐
배열은 값 저장 불가
배열은 포인터가 아니다
1
다음 중 다음 중 malloc 함수의 반환값을 사용하려면 필요한 것은?

형 변환
형태 지정자
NULL 검사
모두 맞음
없음
4
다음 중 함수 포인터를 이용해 함수 호출이 가능한 문장은?

(*fp)(10);
fp(10);
(*fp)();
fp();
모두 맞음
5
다음 중 다음 중 올바른 문자열 비교 함수는?

strcmp(str1, str2);
strcpy(str1, str2);
strlen(str1);
strcat(str1, str2);
strchr(str1, 'c');
1
다음 중 const int *p에서 의미하는 것은?

*p는 변경 불가능
p는 변경 불가능
p와 *p 모두 변경 불가능
*p는 주소값이다
p는 상수이다
1
다음 중 포인터가 동적 메모리 해제 후 사용되는 경우 발생하는 문제는?

댕글링 포인터
메모리 누수
정상 동작
컴파일 에러
메모리 할당 오류
1
다음 중 다음 중 배열 포인터의 선언은?

int (*p)[10];
int *p[10];
int *(*p)[10];
int *(p[10]);
int[10] *p;
1
다음 중 다음 중 NULL 포인터의 용도는?

포인터 초기화
조건 비교
에러 처리
모두 맞음
없음
4
다음 중 포인터를 사용하여 구조체 배열을 처리할 수 있는 이유는?

주소를 이용해 연속된 메모리를 순회할 수 있어서
구조체는 포인터를 포함하지 않아서
포인터가 배열보다 빠르기 때문에
배열은 함수에 전달될 수 없기 때문에
포인터는 자동으로 배열을 생성하기 때문에
1
다음 중 다음 코드에서 올바른 출력 결과는?

char *p = "world"; printf("%c", *(p + 2));
r
o
l
d
w
3
다음 중 다음 중 const int *p와 int *const p의 차이점은?

전자는 값 변경 불가, 후자는 주소 변경 불가
전자는 주소 변경 불가, 후자는 값 변경 불가
둘 다 변경 불가
둘 다 변경 가능
주소만 고정됨
1
다음 중 함수가 포인터를 반환하는 선언으로 올바른 것은?

int* getPointer();
int getPointer*();
*int getPointer();
int &getPointer();
pointer getPointer();
1
다음 중 다음 코드에서 잘못된 부분은?

int arr[3] = {1,2,3}; int *p = arr; printf("%d", *(p + 3));
배열 범위를 벗어난 접근
포인터 선언 오류
초기화 오류
출력 형식 오류
없음
1
다음 중 포인터와 관련된 키워드가 아닌 것은?

sizeof
malloc
free
struct
new
5
다음 중 배열 이름과 포인터 변수의 가장 큰 차이점은?

배열 이름은 상수, 포인터는 변수
둘은 완전히 같다
포인터는 상수, 배열은 변수
배열은 가리킬 수 없다
포인터는 메모리를 사용하지 않는다
1
다음 중 다음 중 구조체 배열에 포인터를 사용할 때의 이점은?

메모리 절약
빠른 접근
코드 단순화
모두 맞음
없음
4
다음 중 포인터를 사용하는 코드에서 오류가 발생할 수 있는 경우는?

초기화되지 않은 포인터 사용
할당되지 않은 메모리 접근
해제된 포인터 사용
NULL 포인터 역참조
모두 맞음
5
다음 중 const 포인터에 대한 설명으로 옳은 것은?

포인터가 가리키는 값은 변경 불가
포인터 자체는 변경 불가
가리키는 값과 포인터 모두 변경 가능
상수에만 사용 가능
const는 컴파일러 지시자
1
다음 중 2차원 배열에서 포인터를 사용할 수 있는 예는?

int arr[3][4]; int (*p)[4] = arr;
int arr[3][4]; int *p[4] = arr;
int arr[3][4]; int p[4] = arr;
int arr[3][4]; int **p = arr;
int arr[3][4]; int *p = &arr;
1
다음 중 동적 메모리 해제 후 반드시 수행해야 하는 작업은?

포인터를 NULL로 설정
포인터를 초기화
포인터를 free
포인터를 ++
포인터를 복사
1
다음 중 포인터 배열 선언으로 올바른 것은?

int arr[5];
int arr[5];
int [5]arr;
int arr[5];
int* arr(5);
1
다음 중 malloc 함수 사용 후 올바른 검사 방법은?

if (p == NULL)
if (p = NULL)
if (NULL == 1)
if (*p == 0)
if (sizeof(p) == 0)
1
다음 중 포인터의 자료형이 중요한 이유는?

연산 시 이동 크기 결정
주소값 자체가 달라지기 때문
포인터가 정수를 저장하기 때문
문자열만 저장 가능하기 때문
포인터는 상수이기 때문
1
다음 중 문자열 상수를 포인터에 저장할 때 주의할 점은?

읽기 전용이므로 수정 금지
항상 동적 할당 필요
배열만 사용 가능
NULL로 끝나지 않음
char 포인터만 가능
1
다음 중 구조체를 함수 인자로 전달할 때 포인터를 사용하는 이유는?

복사 비용을 줄이기 위해
함수 정의가 간단해져서
주소값이 필요 없어서
컴파일 속도가 빨라서
코드 길이를 줄이기 위해
1
다음 중 포인터의 용도로 옳지 않은 것은?

복사 없는 데이터 전달
동적 메모리 관리
주소 조작
컴파일 속도 향상
구조체 접근
4
다음 중 double **ptr; 선언 시 의미는?

포인터를 가리키는 포인터
2차원 배열
double 값을 저장하는 변수
주소가 아닌 값
포인터 배열
1
다음 중 다음 코드의 의미로 맞는 것은?

int a = 5; int *p = &a; *p = 7;
a의 값이 7로 바뀐다
p가 7을 가리킨다
a의 주소가 7이다
a가 포인터다
포인터가 5다
1
다음 중 const int *p와 int const *p의 차이는?

동일하다
전자는 포인터 고정, 후자는 값 고정
전자는 값 고정, 후자는 포인터 고정
둘 다 값과 포인터 고정
의미 없음
1
다음 중 다음 코드에서 p의 자료형으로 올바른 것은?

int arr[5]; int *p = arr;
int *
int
int[5]
int []
int arr
1
다음 중 포인터가 필요한 상황은?

구조체 전달
문자열 처리
동적 메모리 할당
배열 접근
모두 맞음
5
다음 중 포인터 배열과 배열 포인터의 차이에 대한 설명으로 올바른 것은?

포인터 배열은 포인터의 배열이고 배열 포인터는 배열을 가리키는 포인터다
둘은 동일하다
포인터 배열은 2차원 배열이다
배열 포인터는 상수이다
포인터 배열은 주소 연산이 불가능하다
1
다음 중 다음 선언에서 잘못된 부분은?

int *ptr = NULL;
정상
ptr는 값이다
NULL은 정의되지 않음
포인터는 정수값 가질 수 없음
NULL은 포인터가 아니다
1
다음 중 포인터와 함수 포인터의 가장 큰 차이는?

함수 포인터는 함수의 주소를 저장
함수 포인터는 배열처럼 동작
포인터는 함수만 저장
함수 포인터는 메모리 할당이 안됨
일반 포인터보다 작다
1
다음 중 동적 할당된 2차원 배열을 해제할 때 올바른 순서는?

내부 배열 먼저 해제하고 외부 배열
외부 배열 먼저 해제하고 내부 배열
동시에 해제
할당 순서와 상관없음
할당된 포인터는 자동 해제됨
1
다음 중 다음 중 포인터에 주소를 잘못 전달했을 경우 발생할 수 있는 현상은?

세그멘테이션 오류
컴파일 에러
정상 출력
할당 오류
주소 증가
1
다음 중 다음 중 배열과 포인터가 같은 방식으로 동작하지 않는 경우는?

sizeof 연산
인덱싱
주소 전달
포인터 연산
함수 인자로 전달
1
다음 중 포인터 초기화 시 반드시 확인해야 하는 사항은?

NULL 여부
주소 정렬
데이터 크기
데이터 타입
값 여부
1
다음 중 double *ptr = malloc(10 * sizeof(double)); 이후 ptr이 가리키는 영역에 접근할 수 없는 경우는?

할당 실패
오버플로우
포인터 누락
타입 미일치
초기화 누락
1
다음 중 const 키워드가 포인터에 적용될 때 의미하는 것은?

값을 바꿀 수 없다
포인터 주소 변경 불가
값과 주소 모두 변경 가능
포인터는 읽기 전용
컴파일 타임 오류
1
다음 중 다음 코드의 결과로 올바른 것은?

int a = 5, *p = &a; printf("%d", *p);
5
주소 출력
0
에러
쓰레기값
1
다음 중 void 포인터의 특징으로 올바른 것은?

형 변환 없이 역참조 불가
모든 연산 가능
항상 NULL 초기화
정수만 가리킬 수 있음
함수만 가리킬 수 있음
1
다음 중 포인터와 포인터 배열을 구분할 수 있는 기준은?

괄호의 위치
자료형 이름
변수명
포인터 깊이
정의 순서
1
다음 중 malloc과 calloc의 차이로 올바른 것은?

calloc은 초기화됨, malloc은 아님
둘은 완전히 동일
malloc이 더 안전
calloc은 속도가 빠름
malloc은 문자열 전용
1
다음 중 포인터로 문자열 처리 시 주의할 점은?

NULL 체크
읽기 전용 여부
문자열 종료('\0')
메모리 할당
모두 맞음
5
다음 중 다음 코드의 실행 결과는?

char *s = "ABC"; printf("%c", *(s+1));
B
A
C
\0
s
1
다음 중 포인터의 역참조 결과로 알 수 없는 것은?

포인터가 가리키는 값
포인터의 주소
포인터가 유효한지
값의 자료형
값의 메모리 크기
2
다음 중 다중 포인터 사용 이유로 옳지 않은 것은?

함수 포인터 전달
2차원 배열 처리
다차원 데이터
단일 정수 저장
값 수정 전달
4
다음 중 다음 선언에서 오류가 발생하는 것은?

int *p = NULL;
float **pp;
char str = "hi";
double p;
void *vp;
4
다음 중 포인터가 함수에서 값 전달을 흉내낼 수 있는 방식은?

값을 주소로 전달하여 원본 변경
값을 직접 복사
포인터를 값처럼 저장
변수를 값으로 사용
함수를 배열로 처리
1
